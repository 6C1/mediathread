The intent of this document is to keep track of cleanup and
refactoring that I think is worth doing after the initial
launch. Rather than scattering them in PMT items I'll keep them next
to the code itself...

A1. Rename all the templates.

    Currently they have absolutely no naming scheme, and it's really
    confusing. Some of the templates are named according to the
    system's understanding of the views they're associated with
    (e.g. assetmgr/asset_container.html, mapped to /asset/) Others are
    named according to the end user's understanding of the views
    they're associated with (e.g. projects/classlisting.html, mapped
    to /yourspace/)

    I think a good first step here would be to pick a single naming
    scheme for all the templates so there's enough clarity to see
    what's going on.

A2. Distinguish between "software templates" and "site templates".

    For expedience, I put all the templates in the project's top-level
    /templates directory, and haven't made any serious attempt to
    refactor any common widgets or sub-templates out of them, either.

    I started refactoring widgets e.g. templates/projects/asset_table.html
    but haven't done much. These consumable/reusable widgets ought to go
    inside their apps' templates directories rather than the project's 
    global templates directory.

B1. Use django forms properly.

    I wrote some pretty sloppy form validation code by hand; the
    annoyance never got significant enough for me to get around to
    learning how to use django forms. I kinda-sorta started using the
    forms framework, though, but only for form _template_ generation,
    so all the code's in this strange halfway state. And
    djangosherd/views.py in particular has some really awkward code
    that could probably go away with proper use of the forms
    framework.

C1. Figure out a better way to decouple views.py in assetmgr and
    djangosherd, or decide not to.

    This is another instance of awkward code in a halfway state --
    specifically, the code in assetmgr.views:annotationcontainerview
    and assetmgr.views:annotationview, which do strange things to the
    request, call view functions in djangosherd.views, and then modify
    the response. Sort of like middleware, but written and wired as
    views.

    The idea here was that djangosherd's form-handling views should
    remain agnostic to any particular application. So they get the
    annotation's context from the posted form, and also the redirect_to
    URL. But the annotation's context is actually in the request URL
    (e.g. /asset/1/annotation/2/), so assetmgr intercepts the request
    to stuff that information into the form.

    This is all sort of strange and confusing. I think there must be a
    way to do this sanely. But I can't figure out what it is. Unless
    a sane solution is found, this attempt at decoupling is probably
    more trouble than it's worth.

C2. Use generic relations in djangosherd instead of hardcoding
    knowledge about assetmgr.models:Asset objects.

    Maybe? I don't know if it's worth it or not.

D1. Use `djangohelpers`.

    I began to pull out some of the more reusable code into a generic
    library-style app at http://svn.ccnmtl.columbia.edu/djangohelpers/
    
    It forks out code from this project, particularly from `someutils`
    and `projects`. This project should consume that library instead
    of maintaining its own versions of that now-independent code.

D2. Use `courseaffils`.

    Similarly, I started pulling out course affiliation-related code
    from `projects` and into an independent app; it currently lives
    in this project directory, at
    http://svn.ccnmtl.columbia.edu/mondrian/trunk/courseaffils/

D3. Organize the `projects` app.

    As D1 and D2 suggest, the `projects` app is kind of just my
    dumping ground for things that didn't seem to belong anywhere
    else.  D1 and D2 will get rid of a lot of it; whatever remains
    will probably need to be organized in some coherent way.

E1. Use django-usertagging.
